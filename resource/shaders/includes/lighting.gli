#include "uniforms.gli"
#include "math.gli"
#include "clustering.gli"
#include "sg.gli"

#ifndef LIGHTING_H
#define LIGHTING_H

// todo: split the spotlights out
void CalculatePointLighting(uint bucket_index, int lightMode, vec3 position, vec3 normal, vec3 view, vec4 shadows, vec3 albedo, vec3 f0, float roughness, inout vec3 diffuseLight, inout vec3 specularLight)
{	
	// precompute some terms
	float a = roughness;// * roughness;
	float a2 = a;// * a;
	float rcp_a2 = 1.0 / a2;
	float aperture = max(sqrt(1.0 - shadows.w), 0.01);
	vec3 reflVec = reflect(-view, normal);

	float scalar = 0.4; // todo: needs to come from rdCamera_pCurCamera->attenuationMin
	vec3 sssRadius = fillColor.rgb;

	float overdraw = 0.0;

	uint first_item = firstLight;
	uint last_item = first_item + numLights - 1u;
	uint first_bucket = first_item / 32u;
	uint last_bucket = min(last_item / 32u, max(0u, CLUSTER_BUCKETS_PER_CLUSTER - 1u));
	for (uint bucket = first_bucket; bucket <= last_bucket; ++bucket)
	{
		uint bucket_bits = uint(texelFetch(clusterBuffer, int(bucket_index + bucket)).x);
		while(bucket_bits != 0u)
		{
			uint bucket_bit_index = uint(findLSB(bucket_bits));
			uint light_index = bucket * 32u + bucket_bit_index;
			bucket_bits ^= (1u << bucket_bit_index);
				
		#ifdef SPECULAR
			if (light_index >= first_item && light_index <= last_item)
		#else
			if (light_index >= first_item && light_index <= last_item)// && any(lessThan(diffuseLight, vec3(1.0))))
		#endif
			{
				overdraw += 1.0;

				light l = lights[light_index];
				vec3 diff = l.position.xyz - position.xyz;

				float len;

				// diffuse uses dist to plane
				//if (lightMode == 2)
				//	len = dot(l.position.xyz - position.xyz, normal.xyz);
				//else
					len = length(diff);

				if ( len >= l.falloffMin )
					continue;

				float rcpLen = len > 1e-6 ? 1.0 / len : 0.0;
				diff *= rcpLen;

				float intensity = l.direction_intensity.w;
				if(l.type == 3)
				{
					float angle = dot(l.direction_intensity.xyz, diff);
					if (angle <= l.cosAngleY)
						continue;

					if (angle < l.cosAngleX)
                        intensity = (1.0 - (l.cosAngleX - angle) * l.lux) * intensity;
				}

				// this is JK's attenuation model, note it depends on scalar value matching whatever was used to calculate the intensity, it seems
				intensity = max(0.0, intensity - len * scalar);

				//if ((aoFlags & 0x1) == 0x1 && numOccluders > 0u)
				{
					//float localShadow = clamp(dot(shadows.xyz, diff.xyz) / (aperture * 0.3 + 0.7), 0.0, 1.0);
					//intensity *= localShadow;// * localShadow;
				}

				if (intensity <= 0.0)
					continue;
				
				float lightMagnitude = dot(normal, diff);
				float signedMagnitude = lightMagnitude;
				lightMagnitude = max(lightMagnitude, 0.0);

				vec3 cd = vec3(lightMagnitude);
				if (lightMode == 5)
				{
					// https://www.shadertoy.com/view/dltGWl
					vec3 sss = 0.2 * exp(-3.0 * abs(signedMagnitude) / (sssRadius.xyz + 0.001));
					cd.xyz += sssRadius.xyz * sss;
				}
				else if(signedMagnitude <= 0.0)
				{
					continue;
				}

				diffuseLight += l.color.xyz * intensity * cd;

			#ifdef SPECULAR
				//vec3 h = normalize(diff + view);
				vec3 f = f0;// + (1.0 - f0) * exp2(-8.35 * max(0.0, dot(diff, h)));
				//f *= clamp(dot(f0, vec3(333.0)), 0.0, 1.0); // fade out when spec is less than 0.1% albedo
					
				float c = 0.72134752 * rcp_a2 + 0.39674113;
				float d = exp2( c * dot(reflVec, diff) - c ) * (rcp_a2 / 3.141592);

				vec3 cs = f * (lightMagnitude * d);

				specularLight += l.color.xyz * intensity * cs;
			#endif
			}
			else if (light_index > last_item)
			{
				bucket = CLUSTER_BUCKETS_PER_CLUSTER;
				break;
			}
		}
	}

	//diffuseLight.rgb = temperature(overdraw * 0.125);
}


#endif
