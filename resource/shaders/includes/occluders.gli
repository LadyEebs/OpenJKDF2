// occluder/shadow functionality

import "defines.gli"
import "uniforms.gli"
import "math.gli"
import "clustering.gli"
import "sg.gli"

#ifndef OCCLUDERS_H
#define OCCLUDERS_H

void calc_shadow(inout float shadow, uint occluder_index, light_input params)
{
	occluder occ = occluders[occluder_index];

	vec3 viewPos = unpackHalf4x16(params.pos).xyz;
	vec3 direction = vec3(occ.position.xyz - viewPos.xyz);

	float dotVector = dot(direction, direction);
	//if (dotVector >= occ.position.w * occ.position.w)
		//return;
				
	float rcpLen = inversesqrt(dotVector);
	float len = rcpLen * dotVector;
	direction = direction * rcpLen;
		
	vec3 normal = decode_octahedron_uint(params.normal);
	float ndotl = clamp(dot(normal, direction), 0.0, 1.0);
	//if(ndotl <= 0.0)
	//	return;
				
	float falloff = clamp((occ.position.w - len) * occ.invRadius, 0.0, 1.0);
	//if(falloff <= 0.0)
	//	return;
				
	float x = occ.position.w * rcpLen;
	//float solidAngle = (1.0 - cos(atanFast(x)));

	float theta = x * fastRcpNR1(0.28 * (x * x) + 1.0); // approximate atan(x)
	float solidAngle = (0.5 * theta) * theta; // simplified form
	//if (solidAngle <= 0.0)
	//	return;

	float integralSolidAngle = ndotl * solidAngle * falloff;
	shadow *= 1.0 - integralSolidAngle;
}

#endif
